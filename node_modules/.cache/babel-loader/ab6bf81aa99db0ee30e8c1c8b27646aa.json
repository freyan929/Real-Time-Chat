{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\n\nvar qs = require(\"querystring\");\n\nvar url_1 = require(\"url\");\n\nvar base64id = require(\"base64id\");\n\nvar transports_1 = require(\"./transports\");\n\nvar events_1 = require(\"events\");\n\nvar socket_1 = require(\"./socket\");\n\nvar debug_1 = require(\"debug\");\n\nvar cookie_1 = require(\"cookie\");\n\nvar ws_1 = require(\"ws\");\n\nvar debug = (0, debug_1.default)(\"engine\");\n\nvar Server = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Server, _events_1$EventEmitte);\n\n  var _super = _createSuper(Server);\n\n  /**\n   * Server constructor.\n   *\n   * @param {Object} opts - options\n   * @api public\n   */\n  function Server() {\n    var _this;\n\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Server);\n\n    _this = _super.call(this);\n    _this.clients = {};\n    _this.clientsCount = 0;\n    _this.opts = Object.assign({\n      wsEngine: ws_1.Server,\n      pingTimeout: 20000,\n      pingInterval: 25000,\n      upgradeTimeout: 10000,\n      maxHttpBufferSize: 1e6,\n      transports: Object.keys(transports_1.default),\n      allowUpgrades: true,\n      httpCompression: {\n        threshold: 1024\n      },\n      cors: false,\n      allowEIO3: false\n    }, opts);\n\n    if (opts.cookie) {\n      _this.opts.cookie = Object.assign({\n        name: \"io\",\n        path: \"/\",\n        // @ts-ignore\n        httpOnly: opts.cookie.path !== false,\n        sameSite: \"lax\"\n      }, opts.cookie);\n    }\n\n    if (_this.opts.cors) {\n      _this.corsMiddleware = require(\"cors\")(_this.opts.cors);\n    }\n\n    if (opts.perMessageDeflate) {\n      _this.opts.perMessageDeflate = Object.assign({\n        threshold: 1024\n      }, opts.perMessageDeflate);\n    }\n\n    _this.init();\n\n    return _this;\n  }\n  /**\n   * Initialize websocket server\n   *\n   * @api private\n   */\n\n\n  _createClass(Server, [{\n    key: \"init\",\n    value: function init() {\n      var _this2 = this;\n\n      if (!~this.opts.transports.indexOf(\"websocket\")) return;\n      if (this.ws) this.ws.close();\n      this.ws = new this.opts.wsEngine({\n        noServer: true,\n        clientTracking: false,\n        perMessageDeflate: this.opts.perMessageDeflate,\n        maxPayload: this.opts.maxHttpBufferSize\n      });\n\n      if (typeof this.ws.on === \"function\") {\n        this.ws.on(\"headers\", function (headersArray, req) {\n          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n          // we could also try to parse the array and then sync the values, but that will be error-prone\n          var additionalHeaders = {};\n          var isInitialRequest = !req._query.sid;\n\n          if (isInitialRequest) {\n            _this2.emit(\"initial_headers\", additionalHeaders, req);\n          }\n\n          _this2.emit(\"headers\", additionalHeaders, req);\n\n          Object.keys(additionalHeaders).forEach(function (key) {\n            headersArray.push(\"\".concat(key, \": \").concat(additionalHeaders[key]));\n          });\n        });\n      }\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n\n  }, {\n    key: \"upgrades\",\n    value: function upgrades(transport) {\n      if (!this.opts.allowUpgrades) return [];\n      return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(req, upgrade, fn) {\n      // transport check\n      var transport = req._query.transport;\n\n      if (!~this.opts.transports.indexOf(transport)) {\n        debug('unknown transport \"%s\"', transport);\n        return fn(Server.errors.UNKNOWN_TRANSPORT, {\n          transport: transport\n        });\n      } // 'Origin' header check\n\n\n      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n\n      if (isOriginInvalid) {\n        var origin = req.headers.origin;\n        req.headers.origin = null;\n        debug(\"origin header invalid\");\n        return fn(Server.errors.BAD_REQUEST, {\n          name: \"INVALID_ORIGIN\",\n          origin: origin\n        });\n      } // sid check\n\n\n      var sid = req._query.sid;\n\n      if (sid) {\n        if (!this.clients.hasOwnProperty(sid)) {\n          debug('unknown sid \"%s\"', sid);\n          return fn(Server.errors.UNKNOWN_SID, {\n            sid: sid\n          });\n        }\n\n        var previousTransport = this.clients[sid].transport.name;\n\n        if (!upgrade && previousTransport !== transport) {\n          debug(\"bad request: unexpected transport without upgrade\");\n          return fn(Server.errors.BAD_REQUEST, {\n            name: \"TRANSPORT_MISMATCH\",\n            transport: transport,\n            previousTransport: previousTransport\n          });\n        }\n      } else {\n        // handshake is GET only\n        if (\"GET\" !== req.method) {\n          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n            method: req.method\n          });\n        }\n\n        if (!this.opts.allowRequest) return fn();\n        return this.opts.allowRequest(req, function (message, success) {\n          if (!success) {\n            return fn(Server.errors.FORBIDDEN, {\n              message: message\n            });\n          }\n\n          fn();\n        });\n      }\n\n      fn();\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"prepare\",\n    value: function prepare(req) {\n      // try to leverage pre-existing `req._query` (e.g: from connect)\n      if (!req._query) {\n        req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n      }\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      debug(\"closing all open clients\");\n\n      for (var i in this.clients) {\n        if (this.clients.hasOwnProperty(i)) {\n          this.clients[i].close(true);\n        }\n      }\n\n      if (this.ws) {\n        debug(\"closing webSocketServer\");\n        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again\n      }\n\n      return this;\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {http.ServerResponse|http.OutgoingMessage} response\n     * @api public\n     */\n\n  }, {\n    key: \"handleRequest\",\n    value: function handleRequest(req, res) {\n      var _this3 = this;\n\n      debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n      this.prepare(req);\n      req.res = res;\n\n      var callback = function callback(errorCode, errorContext) {\n        if (errorCode !== undefined) {\n          _this3.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortRequest(res, errorCode, errorContext);\n          return;\n        }\n\n        if (req._query.sid) {\n          debug(\"setting new request for existing client\");\n\n          _this3.clients[req._query.sid].transport.onRequest(req);\n        } else {\n          var closeConnection = function closeConnection(errorCode, errorContext) {\n            return abortRequest(res, errorCode, errorContext);\n          };\n\n          _this3.handshake(req._query.transport, req, closeConnection);\n        }\n      };\n\n      if (this.corsMiddleware) {\n        this.corsMiddleware.call(null, req, res, function () {\n          _this3.verify(req, false, callback);\n        });\n      } else {\n        this.verify(req, false, callback);\n      }\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n\n  }, {\n    key: \"generateId\",\n    value: function generateId(req) {\n      return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api private\n     */\n\n  }, {\n    key: \"handshake\",\n    value: function () {\n      var _handshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(transportName, req, closeConnection) {\n        var _this4 = this;\n\n        var protocol, id, transport, socket;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n\n                if (!(protocol === 3 && !this.opts.allowEIO3)) {\n                  _context.next = 6;\n                  break;\n                }\n\n                debug(\"unsupported protocol version\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                  message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                  context: {\n                    protocol: protocol\n                  }\n                });\n                closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n                return _context.abrupt(\"return\");\n\n              case 6:\n                _context.prev = 6;\n                _context.next = 9;\n                return this.generateId(req);\n\n              case 9:\n                id = _context.sent;\n                _context.next = 18;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](6);\n                debug(\"error while generating an id\");\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: _context.t0\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 18:\n                debug('handshaking client \"%s\"', id);\n                _context.prev = 19;\n                transport = new transports_1.default[transportName](req);\n\n                if (\"polling\" === transportName) {\n                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                  transport.httpCompression = this.opts.httpCompression;\n                } else if (\"websocket\" === transportName) {\n                  transport.perMessageDeflate = this.opts.perMessageDeflate;\n                }\n\n                if (req._query && req._query.b64) {\n                  transport.supportsBinary = false;\n                } else {\n                  transport.supportsBinary = true;\n                }\n\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t1 = _context[\"catch\"](19);\n                debug('error handshaking to transport \"%s\"', transportName);\n                this.emit(\"connection_error\", {\n                  req: req,\n                  code: Server.errors.BAD_REQUEST,\n                  message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                  context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: _context.t1\n                  }\n                });\n                closeConnection(Server.errors.BAD_REQUEST);\n                return _context.abrupt(\"return\");\n\n              case 31:\n                socket = new socket_1.Socket(id, this, transport, req, protocol);\n                transport.on(\"headers\", function (headers, req) {\n                  var isInitialRequest = !req._query.sid;\n\n                  if (isInitialRequest) {\n                    if (_this4.opts.cookie) {\n                      headers[\"Set-Cookie\"] = [// @ts-ignore\n                      (0, cookie_1.serialize)(_this4.opts.cookie.name, id, _this4.opts.cookie)];\n                    }\n\n                    _this4.emit(\"initial_headers\", headers, req);\n                  }\n\n                  _this4.emit(\"headers\", headers, req);\n                });\n                transport.onRequest(req);\n                this.clients[id] = socket;\n                this.clientsCount++;\n                socket.once(\"close\", function () {\n                  delete _this4.clients[id];\n                  _this4.clientsCount--;\n                });\n                this.emit(\"connection\", socket);\n\n              case 38:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[6, 12], [19, 25]]);\n      }));\n\n      function handshake(_x, _x2, _x3) {\n        return _handshake.apply(this, arguments);\n      }\n\n      return handshake;\n    }()\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n\n  }, {\n    key: \"handleUpgrade\",\n    value: function handleUpgrade(req, socket, upgradeHead) {\n      var _this5 = this;\n\n      this.prepare(req);\n      this.verify(req, true, function (errorCode, errorContext) {\n        if (errorCode) {\n          _this5.emit(\"connection_error\", {\n            req: req,\n            code: errorCode,\n            message: Server.errorMessages[errorCode],\n            context: errorContext\n          });\n\n          abortUpgrade(socket, errorCode, errorContext);\n          return;\n        }\n\n        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n\n        upgradeHead = null; // delegate to ws\n\n        _this5.ws.handleUpgrade(req, socket, head, function (websocket) {\n          _this5.onWebSocket(req, socket, websocket);\n        });\n      });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n\n  }, {\n    key: \"onWebSocket\",\n    value: function onWebSocket(req, socket, websocket) {\n      websocket.on(\"error\", onUpgradeError);\n\n      if (transports_1.default[req._query.transport] !== undefined && !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n        debug(\"transport doesnt handle upgraded requests\");\n        websocket.close();\n        return;\n      } // get client id\n\n\n      var id = req._query.sid; // keep a reference to the ws.Socket\n\n      req.websocket = websocket;\n\n      if (id) {\n        var client = this.clients[id];\n\n        if (!client) {\n          debug(\"upgrade attempt for closed client\");\n          websocket.close();\n        } else if (client.upgrading) {\n          debug(\"transport has already been trying to upgrade\");\n          websocket.close();\n        } else if (client.upgraded) {\n          debug(\"transport had already been upgraded\");\n          websocket.close();\n        } else {\n          debug(\"upgrading existing transport\"); // transport error handling takes over\n\n          websocket.removeListener(\"error\", onUpgradeError);\n          var transport = new transports_1.default[req._query.transport](req);\n\n          if (req._query && req._query.b64) {\n            transport.supportsBinary = false;\n          } else {\n            transport.supportsBinary = true;\n          }\n\n          transport.perMessageDeflate = this.perMessageDeflate;\n          client.maybeUpgrade(transport);\n        }\n      } else {\n        // transport error handling takes over\n        websocket.removeListener(\"error\", onUpgradeError);\n\n        var closeConnection = function closeConnection(errorCode, errorContext) {\n          return abortUpgrade(socket, errorCode, errorContext);\n        };\n\n        this.handshake(req._query.transport, req, closeConnection);\n      }\n\n      function onUpgradeError() {\n        debug(\"websocket error before upgrade\"); // websocket.close() not needed\n      }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n\n  }, {\n    key: \"attach\",\n    value: function attach(server) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path\n\n      path += \"/\";\n\n      function check(req) {\n        return path === req.url.substr(0, path.length);\n      } // cache and clean up listeners\n\n\n      var listeners = server.listeners(\"request\").slice(0);\n      server.removeAllListeners(\"request\");\n      server.on(\"close\", this.close.bind(this));\n      server.on(\"listening\", this.init.bind(this)); // add request handler\n\n      server.on(\"request\", function (req, res) {\n        if (check(req)) {\n          debug('intercepting request for path \"%s\"', path);\n\n          _this6.handleRequest(req, res);\n        } else {\n          var i = 0;\n          var l = listeners.length;\n\n          for (; i < l; i++) {\n            listeners[i].call(server, req, res);\n          }\n        }\n      });\n\n      if (~this.opts.transports.indexOf(\"websocket\")) {\n        server.on(\"upgrade\", function (req, socket, head) {\n          if (check(req)) {\n            _this6.handleUpgrade(req, socket, head);\n          } else if (false !== options.destroyUpgrade) {\n            // default node behavior is to disconnect when no handlers\n            // but by adding a handler, we prevent that\n            // and if no eio thing handles the upgrade\n            // then the socket needs to die!\n            setTimeout(function () {\n              if (socket.writable && socket.bytesWritten <= 0) {\n                return socket.end();\n              }\n            }, destroyUpgradeTimeout);\n          }\n        });\n      }\n    }\n  }]);\n\n  return Server;\n}(events_1.EventEmitter);\n\nexports.Server = Server;\n/**\n * Protocol errors mappings.\n */\n\nServer.errors = {\n  UNKNOWN_TRANSPORT: 0,\n  UNKNOWN_SID: 1,\n  BAD_HANDSHAKE_METHOD: 2,\n  BAD_REQUEST: 3,\n  FORBIDDEN: 4,\n  UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nServer.errorMessages = {\n  0: \"Transport unknown\",\n  1: \"Session ID unknown\",\n  2: \"Bad handshake method\",\n  3: \"Bad request\",\n  4: \"Forbidden\",\n  5: \"Unsupported protocol version\"\n};\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\n\nfunction abortRequest(res, errorCode, errorContext) {\n  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];\n  res.writeHead(statusCode, {\n    \"Content-Type\": \"application/json\"\n  });\n  res.end(JSON.stringify({\n    code: errorCode,\n    message: message\n  }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\n\n\nfunction abortUpgrade(socket, errorCode) {\n  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  socket.on(\"error\", function () {\n    debug(\"ignoring error from closed connection\");\n  });\n\n  if (socket.writable) {\n    var message = errorContext.message || Server.errorMessages[errorCode];\n    var length = Buffer.byteLength(message);\n    socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" + \"Connection: close\\r\\n\" + \"Content-type: text/html\\r\\n\" + \"Content-Length: \" + length + \"\\r\\n\" + \"\\r\\n\" + message);\n  }\n\n  socket.destroy();\n}\n/* eslint-disable */\n\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\n\n\nvar validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\n\nfunction checkInvalidHeaderChar(val) {\n  val += \"\";\n  if (val.length < 1) return false;\n\n  if (!validHdrChars[val.charCodeAt(0)]) {\n    debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n    return true;\n  }\n\n  if (val.length < 2) return false;\n\n  if (!validHdrChars[val.charCodeAt(1)]) {\n    debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n    return true;\n  }\n\n  if (val.length < 3) return false;\n\n  if (!validHdrChars[val.charCodeAt(2)]) {\n    debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n    return true;\n  }\n\n  if (val.length < 4) return false;\n\n  if (!validHdrChars[val.charCodeAt(3)]) {\n    debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n    return true;\n  }\n\n  for (var i = 4; i < val.length; ++i) {\n    if (!validHdrChars[val.charCodeAt(i)]) {\n      debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n      return true;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/student/Desktop/Real-Time-Chat/real-time-chat/node_modules/engine.io/build/server.js"],"names":["Object","defineProperty","exports","value","Server","qs","require","url_1","base64id","transports_1","events_1","socket_1","debug_1","cookie_1","ws_1","debug","default","opts","clients","clientsCount","assign","wsEngine","pingTimeout","pingInterval","upgradeTimeout","maxHttpBufferSize","transports","keys","allowUpgrades","httpCompression","threshold","cors","allowEIO3","cookie","name","path","httpOnly","sameSite","corsMiddleware","perMessageDeflate","init","indexOf","ws","close","noServer","clientTracking","maxPayload","on","headersArray","req","additionalHeaders","isInitialRequest","_query","sid","emit","forEach","key","push","transport","upgradesTo","upgrade","fn","errors","UNKNOWN_TRANSPORT","isOriginInvalid","checkInvalidHeaderChar","headers","origin","BAD_REQUEST","hasOwnProperty","UNKNOWN_SID","previousTransport","method","BAD_HANDSHAKE_METHOD","allowRequest","message","success","FORBIDDEN","url","parse","query","i","res","prepare","callback","errorCode","errorContext","undefined","code","errorMessages","context","abortRequest","onRequest","closeConnection","handshake","call","verify","generateId","transportName","protocol","EIO","UNSUPPORTED_PROTOCOL_VERSION","id","error","b64","supportsBinary","socket","Socket","serialize","once","upgradeHead","abortUpgrade","head","Buffer","from","handleUpgrade","websocket","onWebSocket","onUpgradeError","prototype","handlesUpgrades","client","upgrading","upgraded","removeListener","maybeUpgrade","server","options","replace","destroyUpgradeTimeout","check","substr","length","listeners","slice","removeAllListeners","bind","handleRequest","l","destroyUpgrade","setTimeout","writable","bytesWritten","end","EventEmitter","statusCode","writeHead","JSON","stringify","byteLength","write","destroy","validHdrChars","val","charCodeAt"],"mappings":"AAAA;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,MAAR,GAAiB,KAAK,CAAtB;;AACA,IAAMC,EAAE,GAAGC,OAAO,CAAC,aAAD,CAAlB;;AACA,IAAMC,KAAK,GAAGD,OAAO,CAAC,KAAD,CAArB;;AACA,IAAME,QAAQ,GAAGF,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMG,YAAY,GAAGH,OAAO,CAAC,cAAD,CAA5B;;AACA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMK,QAAQ,GAAGL,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMM,OAAO,GAAGN,OAAO,CAAC,OAAD,CAAvB;;AACA,IAAMO,QAAQ,GAAGP,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMQ,IAAI,GAAGR,OAAO,CAAC,IAAD,CAApB;;AACA,IAAMS,KAAK,GAAG,CAAC,GAAGH,OAAO,CAACI,OAAZ,EAAqB,QAArB,CAAd;;IACMZ,M;;;;;AACF;AACJ;AACA;AACA;AACA;AACA;AACI,oBAAuB;AAAA;;AAAA,QAAXa,IAAW,uEAAJ,EAAI;;AAAA;;AACnB;AACA,UAAKC,OAAL,GAAe,EAAf;AACA,UAAKC,YAAL,GAAoB,CAApB;AACA,UAAKF,IAAL,GAAYjB,MAAM,CAACoB,MAAP,CAAc;AACtBC,MAAAA,QAAQ,EAAEP,IAAI,CAACV,MADO;AAEtBkB,MAAAA,WAAW,EAAE,KAFS;AAGtBC,MAAAA,YAAY,EAAE,KAHQ;AAItBC,MAAAA,cAAc,EAAE,KAJM;AAKtBC,MAAAA,iBAAiB,EAAE,GALG;AAMtBC,MAAAA,UAAU,EAAE1B,MAAM,CAAC2B,IAAP,CAAYlB,YAAY,CAACO,OAAzB,CANU;AAOtBY,MAAAA,aAAa,EAAE,IAPO;AAQtBC,MAAAA,eAAe,EAAE;AACbC,QAAAA,SAAS,EAAE;AADE,OARK;AAWtBC,MAAAA,IAAI,EAAE,KAXgB;AAYtBC,MAAAA,SAAS,EAAE;AAZW,KAAd,EAaTf,IAbS,CAAZ;;AAcA,QAAIA,IAAI,CAACgB,MAAT,EAAiB;AACb,YAAKhB,IAAL,CAAUgB,MAAV,GAAmBjC,MAAM,CAACoB,MAAP,CAAc;AAC7Bc,QAAAA,IAAI,EAAE,IADuB;AAE7BC,QAAAA,IAAI,EAAE,GAFuB;AAG7B;AACAC,QAAAA,QAAQ,EAAEnB,IAAI,CAACgB,MAAL,CAAYE,IAAZ,KAAqB,KAJF;AAK7BE,QAAAA,QAAQ,EAAE;AALmB,OAAd,EAMhBpB,IAAI,CAACgB,MANW,CAAnB;AAOH;;AACD,QAAI,MAAKhB,IAAL,CAAUc,IAAd,EAAoB;AAChB,YAAKO,cAAL,GAAsBhC,OAAO,CAAC,MAAD,CAAP,CAAgB,MAAKW,IAAL,CAAUc,IAA1B,CAAtB;AACH;;AACD,QAAId,IAAI,CAACsB,iBAAT,EAA4B;AACxB,YAAKtB,IAAL,CAAUsB,iBAAV,GAA8BvC,MAAM,CAACoB,MAAP,CAAc;AACxCU,QAAAA,SAAS,EAAE;AAD6B,OAAd,EAE3Bb,IAAI,CAACsB,iBAFsB,CAA9B;AAGH;;AACD,UAAKC,IAAL;;AAnCmB;AAoCtB;AACD;AACJ;AACA;AACA;AACA;;;;;WACI,gBAAO;AAAA;;AACH,UAAI,CAAC,CAAC,KAAKvB,IAAL,CAAUS,UAAV,CAAqBe,OAArB,CAA6B,WAA7B,CAAN,EACI;AACJ,UAAI,KAAKC,EAAT,EACI,KAAKA,EAAL,CAAQC,KAAR;AACJ,WAAKD,EAAL,GAAU,IAAI,KAAKzB,IAAL,CAAUI,QAAd,CAAuB;AAC7BuB,QAAAA,QAAQ,EAAE,IADmB;AAE7BC,QAAAA,cAAc,EAAE,KAFa;AAG7BN,QAAAA,iBAAiB,EAAE,KAAKtB,IAAL,CAAUsB,iBAHA;AAI7BO,QAAAA,UAAU,EAAE,KAAK7B,IAAL,CAAUQ;AAJO,OAAvB,CAAV;;AAMA,UAAI,OAAO,KAAKiB,EAAL,CAAQK,EAAf,KAAsB,UAA1B,EAAsC;AAClC,aAAKL,EAAL,CAAQK,EAAR,CAAW,SAAX,EAAsB,UAACC,YAAD,EAAeC,GAAf,EAAuB;AACzC;AACA;AACA,cAAMC,iBAAiB,GAAG,EAA1B;AACA,cAAMC,gBAAgB,GAAG,CAACF,GAAG,CAACG,MAAJ,CAAWC,GAArC;;AACA,cAAIF,gBAAJ,EAAsB;AAClB,YAAA,MAAI,CAACG,IAAL,CAAU,iBAAV,EAA6BJ,iBAA7B,EAAgDD,GAAhD;AACH;;AACD,UAAA,MAAI,CAACK,IAAL,CAAU,SAAV,EAAqBJ,iBAArB,EAAwCD,GAAxC;;AACAjD,UAAAA,MAAM,CAAC2B,IAAP,CAAYuB,iBAAZ,EAA+BK,OAA/B,CAAuC,UAAAC,GAAG,EAAI;AAC1CR,YAAAA,YAAY,CAACS,IAAb,WAAqBD,GAArB,eAA6BN,iBAAiB,CAACM,GAAD,CAA9C;AACH,WAFD;AAGH,SAZD;AAaH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,kBAASE,SAAT,EAAoB;AAChB,UAAI,CAAC,KAAKzC,IAAL,CAAUW,aAAf,EACI,OAAO,EAAP;AACJ,aAAOnB,YAAY,CAACO,OAAb,CAAqB0C,SAArB,EAAgCC,UAAhC,IAA8C,EAArD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAOV,GAAP,EAAYW,OAAZ,EAAqBC,EAArB,EAAyB;AACrB;AACA,UAAMH,SAAS,GAAGT,GAAG,CAACG,MAAJ,CAAWM,SAA7B;;AACA,UAAI,CAAC,CAAC,KAAKzC,IAAL,CAAUS,UAAV,CAAqBe,OAArB,CAA6BiB,SAA7B,CAAN,EAA+C;AAC3C3C,QAAAA,KAAK,CAAC,wBAAD,EAA2B2C,SAA3B,CAAL;AACA,eAAOG,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAcC,iBAAf,EAAkC;AAAEL,UAAAA,SAAS,EAATA;AAAF,SAAlC,CAAT;AACH,OANoB,CAOrB;;;AACA,UAAMM,eAAe,GAAGC,sBAAsB,CAAChB,GAAG,CAACiB,OAAJ,CAAYC,MAAb,CAA9C;;AACA,UAAIH,eAAJ,EAAqB;AACjB,YAAMG,MAAM,GAAGlB,GAAG,CAACiB,OAAJ,CAAYC,MAA3B;AACAlB,QAAAA,GAAG,CAACiB,OAAJ,CAAYC,MAAZ,GAAqB,IAArB;AACApD,QAAAA,KAAK,CAAC,uBAAD,CAAL;AACA,eAAO8C,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAcM,WAAf,EAA4B;AACjClC,UAAAA,IAAI,EAAE,gBAD2B;AAEjCiC,UAAAA,MAAM,EAANA;AAFiC,SAA5B,CAAT;AAIH,OAjBoB,CAkBrB;;;AACA,UAAMd,GAAG,GAAGJ,GAAG,CAACG,MAAJ,CAAWC,GAAvB;;AACA,UAAIA,GAAJ,EAAS;AACL,YAAI,CAAC,KAAKnC,OAAL,CAAamD,cAAb,CAA4BhB,GAA5B,CAAL,EAAuC;AACnCtC,UAAAA,KAAK,CAAC,kBAAD,EAAqBsC,GAArB,CAAL;AACA,iBAAOQ,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAcQ,WAAf,EAA4B;AACjCjB,YAAAA,GAAG,EAAHA;AADiC,WAA5B,CAAT;AAGH;;AACD,YAAMkB,iBAAiB,GAAG,KAAKrD,OAAL,CAAamC,GAAb,EAAkBK,SAAlB,CAA4BxB,IAAtD;;AACA,YAAI,CAAC0B,OAAD,IAAYW,iBAAiB,KAAKb,SAAtC,EAAiD;AAC7C3C,UAAAA,KAAK,CAAC,mDAAD,CAAL;AACA,iBAAO8C,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAcM,WAAf,EAA4B;AACjClC,YAAAA,IAAI,EAAE,oBAD2B;AAEjCwB,YAAAA,SAAS,EAATA,SAFiC;AAGjCa,YAAAA,iBAAiB,EAAjBA;AAHiC,WAA5B,CAAT;AAKH;AACJ,OAhBD,MAiBK;AACD;AACA,YAAI,UAAUtB,GAAG,CAACuB,MAAlB,EAA0B;AACtB,iBAAOX,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAcW,oBAAf,EAAqC;AAC1CD,YAAAA,MAAM,EAAEvB,GAAG,CAACuB;AAD8B,WAArC,CAAT;AAGH;;AACD,YAAI,CAAC,KAAKvD,IAAL,CAAUyD,YAAf,EACI,OAAOb,EAAE,EAAT;AACJ,eAAO,KAAK5C,IAAL,CAAUyD,YAAV,CAAuBzB,GAAvB,EAA4B,UAAC0B,OAAD,EAAUC,OAAV,EAAsB;AACrD,cAAI,CAACA,OAAL,EAAc;AACV,mBAAOf,EAAE,CAACzD,MAAM,CAAC0D,MAAP,CAAce,SAAf,EAA0B;AAC/BF,cAAAA,OAAO,EAAPA;AAD+B,aAA1B,CAAT;AAGH;;AACDd,UAAAA,EAAE;AACL,SAPM,CAAP;AAQH;;AACDA,MAAAA,EAAE;AACL;AACD;AACJ;AACA;AACA;AACA;;;;WACI,iBAAQZ,GAAR,EAAa;AACT;AACA,UAAI,CAACA,GAAG,CAACG,MAAT,EAAiB;AACbH,QAAAA,GAAG,CAACG,MAAJ,GAAa,CAACH,GAAG,CAAC6B,GAAJ,CAAQrC,OAAR,CAAgB,GAAhB,CAAD,GAAwBpC,EAAE,CAAC0E,KAAH,CAAS,CAAC,GAAGxE,KAAK,CAACwE,KAAV,EAAiB9B,GAAG,CAAC6B,GAArB,EAA0BE,KAAnC,CAAxB,GAAoE,EAAjF;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;;;;WACI,iBAAQ;AACJjE,MAAAA,KAAK,CAAC,0BAAD,CAAL;;AACA,WAAK,IAAIkE,CAAT,IAAc,KAAK/D,OAAnB,EAA4B;AACxB,YAAI,KAAKA,OAAL,CAAamD,cAAb,CAA4BY,CAA5B,CAAJ,EAAoC;AAChC,eAAK/D,OAAL,CAAa+D,CAAb,EAAgBtC,KAAhB,CAAsB,IAAtB;AACH;AACJ;;AACD,UAAI,KAAKD,EAAT,EAAa;AACT3B,QAAAA,KAAK,CAAC,yBAAD,CAAL;AACA,aAAK2B,EAAL,CAAQC,KAAR,GAFS,CAGT;AACH;;AACD,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,uBAAcM,GAAd,EAAmBiC,GAAnB,EAAwB;AAAA;;AACpBnE,MAAAA,KAAK,CAAC,iCAAD,EAAoCkC,GAAG,CAACuB,MAAxC,EAAgDvB,GAAG,CAAC6B,GAApD,CAAL;AACA,WAAKK,OAAL,CAAalC,GAAb;AACAA,MAAAA,GAAG,CAACiC,GAAJ,GAAUA,GAAV;;AACA,UAAME,QAAQ,GAAG,SAAXA,QAAW,CAACC,SAAD,EAAYC,YAAZ,EAA6B;AAC1C,YAAID,SAAS,KAAKE,SAAlB,EAA6B;AACzB,UAAA,MAAI,CAACjC,IAAL,CAAU,kBAAV,EAA8B;AAC1BL,YAAAA,GAAG,EAAHA,GAD0B;AAE1BuC,YAAAA,IAAI,EAAEH,SAFoB;AAG1BV,YAAAA,OAAO,EAAEvE,MAAM,CAACqF,aAAP,CAAqBJ,SAArB,CAHiB;AAI1BK,YAAAA,OAAO,EAAEJ;AAJiB,WAA9B;;AAMAK,UAAAA,YAAY,CAACT,GAAD,EAAMG,SAAN,EAAiBC,YAAjB,CAAZ;AACA;AACH;;AACD,YAAIrC,GAAG,CAACG,MAAJ,CAAWC,GAAf,EAAoB;AAChBtC,UAAAA,KAAK,CAAC,yCAAD,CAAL;;AACA,UAAA,MAAI,CAACG,OAAL,CAAa+B,GAAG,CAACG,MAAJ,CAAWC,GAAxB,EAA6BK,SAA7B,CAAuCkC,SAAvC,CAAiD3C,GAAjD;AACH,SAHD,MAIK;AACD,cAAM4C,eAAe,GAAG,SAAlBA,eAAkB,CAACR,SAAD,EAAYC,YAAZ;AAAA,mBAA6BK,YAAY,CAACT,GAAD,EAAMG,SAAN,EAAiBC,YAAjB,CAAzC;AAAA,WAAxB;;AACA,UAAA,MAAI,CAACQ,SAAL,CAAe7C,GAAG,CAACG,MAAJ,CAAWM,SAA1B,EAAqCT,GAArC,EAA0C4C,eAA1C;AACH;AACJ,OAnBD;;AAoBA,UAAI,KAAKvD,cAAT,EAAyB;AACrB,aAAKA,cAAL,CAAoByD,IAApB,CAAyB,IAAzB,EAA+B9C,GAA/B,EAAoCiC,GAApC,EAAyC,YAAM;AAC3C,UAAA,MAAI,CAACc,MAAL,CAAY/C,GAAZ,EAAiB,KAAjB,EAAwBmC,QAAxB;AACH,SAFD;AAGH,OAJD,MAKK;AACD,aAAKY,MAAL,CAAY/C,GAAZ,EAAiB,KAAjB,EAAwBmC,QAAxB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,oBAAWnC,GAAX,EAAgB;AACZ,aAAOzC,QAAQ,CAACyF,UAAT,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;gFACI,iBAAgBC,aAAhB,EAA+BjD,GAA/B,EAAoC4C,eAApC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACUM,gBAAAA,QADV,GACqBlD,GAAG,CAACG,MAAJ,CAAWgD,GAAX,KAAmB,GAAnB,GAAyB,CAAzB,GAA6B,CADlD,EACqD;;AADrD,sBAEQD,QAAQ,KAAK,CAAb,IAAkB,CAAC,KAAKlF,IAAL,CAAUe,SAFrC;AAAA;AAAA;AAAA;;AAGQjB,gBAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,qBAAKuC,IAAL,CAAU,kBAAV,EAA8B;AAC1BL,kBAAAA,GAAG,EAAHA,GAD0B;AAE1BuC,kBAAAA,IAAI,EAAEpF,MAAM,CAAC0D,MAAP,CAAcuC,4BAFM;AAG1B1B,kBAAAA,OAAO,EAAEvE,MAAM,CAACqF,aAAP,CAAqBrF,MAAM,CAAC0D,MAAP,CAAcuC,4BAAnC,CAHiB;AAI1BX,kBAAAA,OAAO,EAAE;AACLS,oBAAAA,QAAQ,EAARA;AADK;AAJiB,iBAA9B;AAQAN,gBAAAA,eAAe,CAACzF,MAAM,CAAC0D,MAAP,CAAcuC,4BAAf,CAAf;AAZR;;AAAA;AAAA;AAAA;AAAA,uBAiBmB,KAAKJ,UAAL,CAAgBhD,GAAhB,CAjBnB;;AAAA;AAiBQqD,gBAAAA,EAjBR;AAAA;AAAA;;AAAA;AAAA;AAAA;AAoBQvF,gBAAAA,KAAK,CAAC,8BAAD,CAAL;AACA,qBAAKuC,IAAL,CAAU,kBAAV,EAA8B;AAC1BL,kBAAAA,GAAG,EAAHA,GAD0B;AAE1BuC,kBAAAA,IAAI,EAAEpF,MAAM,CAAC0D,MAAP,CAAcM,WAFM;AAG1BO,kBAAAA,OAAO,EAAEvE,MAAM,CAACqF,aAAP,CAAqBrF,MAAM,CAAC0D,MAAP,CAAcM,WAAnC,CAHiB;AAI1BsB,kBAAAA,OAAO,EAAE;AACLxD,oBAAAA,IAAI,EAAE,qBADD;AAELqE,oBAAAA,KAAK;AAFA;AAJiB,iBAA9B;AASAV,gBAAAA,eAAe,CAACzF,MAAM,CAAC0D,MAAP,CAAcM,WAAf,CAAf;AA9BR;;AAAA;AAiCIrD,gBAAAA,KAAK,CAAC,yBAAD,EAA4BuF,EAA5B,CAAL;AAjCJ;AAmCY5C,gBAAAA,SAnCZ,GAmCwB,IAAIjD,YAAY,CAACO,OAAb,CAAqBkF,aAArB,CAAJ,CAAwCjD,GAAxC,CAnCxB;;AAoCQ,oBAAI,cAAciD,aAAlB,EAAiC;AAC7BxC,kBAAAA,SAAS,CAACjC,iBAAV,GAA8B,KAAKR,IAAL,CAAUQ,iBAAxC;AACAiC,kBAAAA,SAAS,CAAC7B,eAAV,GAA4B,KAAKZ,IAAL,CAAUY,eAAtC;AACH,iBAHD,MAIK,IAAI,gBAAgBqE,aAApB,EAAmC;AACpCxC,kBAAAA,SAAS,CAACnB,iBAAV,GAA8B,KAAKtB,IAAL,CAAUsB,iBAAxC;AACH;;AACD,oBAAIU,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACG,MAAJ,CAAWoD,GAA7B,EAAkC;AAC9B9C,kBAAAA,SAAS,CAAC+C,cAAV,GAA2B,KAA3B;AACH,iBAFD,MAGK;AACD/C,kBAAAA,SAAS,CAAC+C,cAAV,GAA2B,IAA3B;AACH;;AAhDT;AAAA;;AAAA;AAAA;AAAA;AAmDQ1F,gBAAAA,KAAK,CAAC,qCAAD,EAAwCmF,aAAxC,CAAL;AACA,qBAAK5C,IAAL,CAAU,kBAAV,EAA8B;AAC1BL,kBAAAA,GAAG,EAAHA,GAD0B;AAE1BuC,kBAAAA,IAAI,EAAEpF,MAAM,CAAC0D,MAAP,CAAcM,WAFM;AAG1BO,kBAAAA,OAAO,EAAEvE,MAAM,CAACqF,aAAP,CAAqBrF,MAAM,CAAC0D,MAAP,CAAcM,WAAnC,CAHiB;AAI1BsB,kBAAAA,OAAO,EAAE;AACLxD,oBAAAA,IAAI,EAAE,2BADD;AAELqE,oBAAAA,KAAK;AAFA;AAJiB,iBAA9B;AASAV,gBAAAA,eAAe,CAACzF,MAAM,CAAC0D,MAAP,CAAcM,WAAf,CAAf;AA7DR;;AAAA;AAgEUsC,gBAAAA,MAhEV,GAgEmB,IAAI/F,QAAQ,CAACgG,MAAb,CAAoBL,EAApB,EAAwB,IAAxB,EAA8B5C,SAA9B,EAAyCT,GAAzC,EAA8CkD,QAA9C,CAhEnB;AAiEIzC,gBAAAA,SAAS,CAACX,EAAV,CAAa,SAAb,EAAwB,UAACmB,OAAD,EAAUjB,GAAV,EAAkB;AACtC,sBAAME,gBAAgB,GAAG,CAACF,GAAG,CAACG,MAAJ,CAAWC,GAArC;;AACA,sBAAIF,gBAAJ,EAAsB;AAClB,wBAAI,MAAI,CAAClC,IAAL,CAAUgB,MAAd,EAAsB;AAClBiC,sBAAAA,OAAO,CAAC,YAAD,CAAP,GAAwB,CACpB;AACA,uBAAC,GAAGrD,QAAQ,CAAC+F,SAAb,EAAwB,MAAI,CAAC3F,IAAL,CAAUgB,MAAV,CAAiBC,IAAzC,EAA+CoE,EAA/C,EAAmD,MAAI,CAACrF,IAAL,CAAUgB,MAA7D,CAFoB,CAAxB;AAIH;;AACD,oBAAA,MAAI,CAACqB,IAAL,CAAU,iBAAV,EAA6BY,OAA7B,EAAsCjB,GAAtC;AACH;;AACD,kBAAA,MAAI,CAACK,IAAL,CAAU,SAAV,EAAqBY,OAArB,EAA8BjB,GAA9B;AACH,iBAZD;AAaAS,gBAAAA,SAAS,CAACkC,SAAV,CAAoB3C,GAApB;AACA,qBAAK/B,OAAL,CAAaoF,EAAb,IAAmBI,MAAnB;AACA,qBAAKvF,YAAL;AACAuF,gBAAAA,MAAM,CAACG,IAAP,CAAY,OAAZ,EAAqB,YAAM;AACvB,yBAAO,MAAI,CAAC3F,OAAL,CAAaoF,EAAb,CAAP;AACA,kBAAA,MAAI,CAACnF,YAAL;AACH,iBAHD;AAIA,qBAAKmC,IAAL,CAAU,YAAV,EAAwBoD,MAAxB;;AArFJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;AAuFA;AACJ;AACA;AACA;AACA;;;;WACI,uBAAczD,GAAd,EAAmByD,MAAnB,EAA2BI,WAA3B,EAAwC;AAAA;;AACpC,WAAK3B,OAAL,CAAalC,GAAb;AACA,WAAK+C,MAAL,CAAY/C,GAAZ,EAAiB,IAAjB,EAAuB,UAACoC,SAAD,EAAYC,YAAZ,EAA6B;AAChD,YAAID,SAAJ,EAAe;AACX,UAAA,MAAI,CAAC/B,IAAL,CAAU,kBAAV,EAA8B;AAC1BL,YAAAA,GAAG,EAAHA,GAD0B;AAE1BuC,YAAAA,IAAI,EAAEH,SAFoB;AAG1BV,YAAAA,OAAO,EAAEvE,MAAM,CAACqF,aAAP,CAAqBJ,SAArB,CAHiB;AAI1BK,YAAAA,OAAO,EAAEJ;AAJiB,WAA9B;;AAMAyB,UAAAA,YAAY,CAACL,MAAD,EAASrB,SAAT,EAAoBC,YAApB,CAAZ;AACA;AACH;;AACD,YAAM0B,IAAI,GAAGC,MAAM,CAACC,IAAP,CAAYJ,WAAZ,CAAb,CAXgD,CAWT;;AACvCA,QAAAA,WAAW,GAAG,IAAd,CAZgD,CAahD;;AACA,QAAA,MAAI,CAACpE,EAAL,CAAQyE,aAAR,CAAsBlE,GAAtB,EAA2ByD,MAA3B,EAAmCM,IAAnC,EAAyC,UAAAI,SAAS,EAAI;AAClD,UAAA,MAAI,CAACC,WAAL,CAAiBpE,GAAjB,EAAsByD,MAAtB,EAA8BU,SAA9B;AACH,SAFD;AAGH,OAjBD;AAkBH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,qBAAYnE,GAAZ,EAAiByD,MAAjB,EAAyBU,SAAzB,EAAoC;AAChCA,MAAAA,SAAS,CAACrE,EAAV,CAAa,OAAb,EAAsBuE,cAAtB;;AACA,UAAI7G,YAAY,CAACO,OAAb,CAAqBiC,GAAG,CAACG,MAAJ,CAAWM,SAAhC,MAA+C6B,SAA/C,IACA,CAAC9E,YAAY,CAACO,OAAb,CAAqBiC,GAAG,CAACG,MAAJ,CAAWM,SAAhC,EAA2C6D,SAA3C,CAAqDC,eAD1D,EAC2E;AACvEzG,QAAAA,KAAK,CAAC,2CAAD,CAAL;AACAqG,QAAAA,SAAS,CAACzE,KAAV;AACA;AACH,OAP+B,CAQhC;;;AACA,UAAM2D,EAAE,GAAGrD,GAAG,CAACG,MAAJ,CAAWC,GAAtB,CATgC,CAUhC;;AACAJ,MAAAA,GAAG,CAACmE,SAAJ,GAAgBA,SAAhB;;AACA,UAAId,EAAJ,EAAQ;AACJ,YAAMmB,MAAM,GAAG,KAAKvG,OAAL,CAAaoF,EAAb,CAAf;;AACA,YAAI,CAACmB,MAAL,EAAa;AACT1G,UAAAA,KAAK,CAAC,mCAAD,CAAL;AACAqG,UAAAA,SAAS,CAACzE,KAAV;AACH,SAHD,MAIK,IAAI8E,MAAM,CAACC,SAAX,EAAsB;AACvB3G,UAAAA,KAAK,CAAC,8CAAD,CAAL;AACAqG,UAAAA,SAAS,CAACzE,KAAV;AACH,SAHI,MAIA,IAAI8E,MAAM,CAACE,QAAX,EAAqB;AACtB5G,UAAAA,KAAK,CAAC,qCAAD,CAAL;AACAqG,UAAAA,SAAS,CAACzE,KAAV;AACH,SAHI,MAIA;AACD5B,UAAAA,KAAK,CAAC,8BAAD,CAAL,CADC,CAED;;AACAqG,UAAAA,SAAS,CAACQ,cAAV,CAAyB,OAAzB,EAAkCN,cAAlC;AACA,cAAM5D,SAAS,GAAG,IAAIjD,YAAY,CAACO,OAAb,CAAqBiC,GAAG,CAACG,MAAJ,CAAWM,SAAhC,CAAJ,CAA+CT,GAA/C,CAAlB;;AACA,cAAIA,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACG,MAAJ,CAAWoD,GAA7B,EAAkC;AAC9B9C,YAAAA,SAAS,CAAC+C,cAAV,GAA2B,KAA3B;AACH,WAFD,MAGK;AACD/C,YAAAA,SAAS,CAAC+C,cAAV,GAA2B,IAA3B;AACH;;AACD/C,UAAAA,SAAS,CAACnB,iBAAV,GAA8B,KAAKA,iBAAnC;AACAkF,UAAAA,MAAM,CAACI,YAAP,CAAoBnE,SAApB;AACH;AACJ,OA5BD,MA6BK;AACD;AACA0D,QAAAA,SAAS,CAACQ,cAAV,CAAyB,OAAzB,EAAkCN,cAAlC;;AACA,YAAMzB,eAAe,GAAG,SAAlBA,eAAkB,CAACR,SAAD,EAAYC,YAAZ;AAAA,iBAA6ByB,YAAY,CAACL,MAAD,EAASrB,SAAT,EAAoBC,YAApB,CAAzC;AAAA,SAAxB;;AACA,aAAKQ,SAAL,CAAe7C,GAAG,CAACG,MAAJ,CAAWM,SAA1B,EAAqCT,GAArC,EAA0C4C,eAA1C;AACH;;AACD,eAASyB,cAAT,GAA0B;AACtBvG,QAAAA,KAAK,CAAC,gCAAD,CAAL,CADsB,CAEtB;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAO+G,MAAP,EAA6B;AAAA;;AAAA,UAAdC,OAAc,uEAAJ,EAAI;AACzB,UAAI5F,IAAI,GAAG,CAAC4F,OAAO,CAAC5F,IAAR,IAAgB,YAAjB,EAA+B6F,OAA/B,CAAuC,KAAvC,EAA8C,EAA9C,CAAX;AACA,UAAMC,qBAAqB,GAAGF,OAAO,CAACE,qBAAR,IAAiC,IAA/D,CAFyB,CAGzB;;AACA9F,MAAAA,IAAI,IAAI,GAAR;;AACA,eAAS+F,KAAT,CAAejF,GAAf,EAAoB;AAChB,eAAOd,IAAI,KAAKc,GAAG,CAAC6B,GAAJ,CAAQqD,MAAR,CAAe,CAAf,EAAkBhG,IAAI,CAACiG,MAAvB,CAAhB;AACH,OAPwB,CAQzB;;;AACA,UAAMC,SAAS,GAAGP,MAAM,CAACO,SAAP,CAAiB,SAAjB,EAA4BC,KAA5B,CAAkC,CAAlC,CAAlB;AACAR,MAAAA,MAAM,CAACS,kBAAP,CAA0B,SAA1B;AACAT,MAAAA,MAAM,CAAC/E,EAAP,CAAU,OAAV,EAAmB,KAAKJ,KAAL,CAAW6F,IAAX,CAAgB,IAAhB,CAAnB;AACAV,MAAAA,MAAM,CAAC/E,EAAP,CAAU,WAAV,EAAuB,KAAKP,IAAL,CAAUgG,IAAV,CAAe,IAAf,CAAvB,EAZyB,CAazB;;AACAV,MAAAA,MAAM,CAAC/E,EAAP,CAAU,SAAV,EAAqB,UAACE,GAAD,EAAMiC,GAAN,EAAc;AAC/B,YAAIgD,KAAK,CAACjF,GAAD,CAAT,EAAgB;AACZlC,UAAAA,KAAK,CAAC,oCAAD,EAAuCoB,IAAvC,CAAL;;AACA,UAAA,MAAI,CAACsG,aAAL,CAAmBxF,GAAnB,EAAwBiC,GAAxB;AACH,SAHD,MAIK;AACD,cAAID,CAAC,GAAG,CAAR;AACA,cAAMyD,CAAC,GAAGL,SAAS,CAACD,MAApB;;AACA,iBAAOnD,CAAC,GAAGyD,CAAX,EAAczD,CAAC,EAAf,EAAmB;AACfoD,YAAAA,SAAS,CAACpD,CAAD,CAAT,CAAac,IAAb,CAAkB+B,MAAlB,EAA0B7E,GAA1B,EAA+BiC,GAA/B;AACH;AACJ;AACJ,OAZD;;AAaA,UAAI,CAAC,KAAKjE,IAAL,CAAUS,UAAV,CAAqBe,OAArB,CAA6B,WAA7B,CAAL,EAAgD;AAC5CqF,QAAAA,MAAM,CAAC/E,EAAP,CAAU,SAAV,EAAqB,UAACE,GAAD,EAAMyD,MAAN,EAAcM,IAAd,EAAuB;AACxC,cAAIkB,KAAK,CAACjF,GAAD,CAAT,EAAgB;AACZ,YAAA,MAAI,CAACkE,aAAL,CAAmBlE,GAAnB,EAAwByD,MAAxB,EAAgCM,IAAhC;AACH,WAFD,MAGK,IAAI,UAAUe,OAAO,CAACY,cAAtB,EAAsC;AACvC;AACA;AACA;AACA;AACAC,YAAAA,UAAU,CAAC,YAAY;AACnB,kBAAIlC,MAAM,CAACmC,QAAP,IAAmBnC,MAAM,CAACoC,YAAP,IAAuB,CAA9C,EAAiD;AAC7C,uBAAOpC,MAAM,CAACqC,GAAP,EAAP;AACH;AACJ,aAJS,EAIPd,qBAJO,CAAV;AAKH;AACJ,SAfD;AAgBH;AACJ;;;;EA/cgBvH,QAAQ,CAACsI,Y;;AAid9B9I,OAAO,CAACE,MAAR,GAAiBA,MAAjB;AACA;AACA;AACA;;AACAA,MAAM,CAAC0D,MAAP,GAAgB;AACZC,EAAAA,iBAAiB,EAAE,CADP;AAEZO,EAAAA,WAAW,EAAE,CAFD;AAGZG,EAAAA,oBAAoB,EAAE,CAHV;AAIZL,EAAAA,WAAW,EAAE,CAJD;AAKZS,EAAAA,SAAS,EAAE,CALC;AAMZwB,EAAAA,4BAA4B,EAAE;AANlB,CAAhB;AAQAjG,MAAM,CAACqF,aAAP,GAAuB;AACnB,KAAG,mBADgB;AAEnB,KAAG,oBAFgB;AAGnB,KAAG,sBAHgB;AAInB,KAAG,aAJgB;AAKnB,KAAG,WALgB;AAMnB,KAAG;AANgB,CAAvB;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASE,YAAT,CAAsBT,GAAtB,EAA2BG,SAA3B,EAAsCC,YAAtC,EAAoD;AAChD,MAAM2D,UAAU,GAAG5D,SAAS,KAAKjF,MAAM,CAAC0D,MAAP,CAAce,SAA5B,GAAwC,GAAxC,GAA8C,GAAjE;AACA,MAAMF,OAAO,GAAGW,YAAY,IAAIA,YAAY,CAACX,OAA7B,GACVW,YAAY,CAACX,OADH,GAEVvE,MAAM,CAACqF,aAAP,CAAqBJ,SAArB,CAFN;AAGAH,EAAAA,GAAG,CAACgE,SAAJ,CAAcD,UAAd,EAA0B;AAAE,oBAAgB;AAAlB,GAA1B;AACA/D,EAAAA,GAAG,CAAC6D,GAAJ,CAAQI,IAAI,CAACC,SAAL,CAAe;AACnB5D,IAAAA,IAAI,EAAEH,SADa;AAEnBV,IAAAA,OAAO,EAAPA;AAFmB,GAAf,CAAR;AAIH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASoC,YAAT,CAAsBL,MAAtB,EAA8BrB,SAA9B,EAA4D;AAAA,MAAnBC,YAAmB,uEAAJ,EAAI;AACxDoB,EAAAA,MAAM,CAAC3D,EAAP,CAAU,OAAV,EAAmB,YAAM;AACrBhC,IAAAA,KAAK,CAAC,uCAAD,CAAL;AACH,GAFD;;AAGA,MAAI2F,MAAM,CAACmC,QAAX,EAAqB;AACjB,QAAMlE,OAAO,GAAGW,YAAY,CAACX,OAAb,IAAwBvE,MAAM,CAACqF,aAAP,CAAqBJ,SAArB,CAAxC;AACA,QAAM+C,MAAM,GAAGnB,MAAM,CAACoC,UAAP,CAAkB1E,OAAlB,CAAf;AACA+B,IAAAA,MAAM,CAAC4C,KAAP,CAAa,iCACT,uBADS,GAET,6BAFS,GAGT,kBAHS,GAITlB,MAJS,GAKT,MALS,GAMT,MANS,GAOTzD,OAPJ;AAQH;;AACD+B,EAAAA,MAAM,CAAC6C,OAAP;AACH;AACD;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMC,aAAa,GAAG,CAClB,CADkB,EACf,CADe,EACZ,CADY,EACT,CADS,EACN,CADM,EACH,CADG,EACA,CADA,EACG,CADH,EACM,CADN,EACS,CADT,EACY,CADZ,EACe,CADf,EACkB,CADlB,EACqB,CADrB,EACwB,CADxB,EAC2B,CAD3B,EAElB,CAFkB,EAEf,CAFe,EAEZ,CAFY,EAET,CAFS,EAEN,CAFM,EAEH,CAFG,EAEA,CAFA,EAEG,CAFH,EAEM,CAFN,EAES,CAFT,EAEY,CAFZ,EAEe,CAFf,EAEkB,CAFlB,EAEqB,CAFrB,EAEwB,CAFxB,EAE2B,CAF3B,EAGlB,CAHkB,EAGf,CAHe,EAGZ,CAHY,EAGT,CAHS,EAGN,CAHM,EAGH,CAHG,EAGA,CAHA,EAGG,CAHH,EAGM,CAHN,EAGS,CAHT,EAGY,CAHZ,EAGe,CAHf,EAGkB,CAHlB,EAGqB,CAHrB,EAGwB,CAHxB,EAG2B,CAH3B,EAIlB,CAJkB,EAIf,CAJe,EAIZ,CAJY,EAIT,CAJS,EAIN,CAJM,EAIH,CAJG,EAIA,CAJA,EAIG,CAJH,EAIM,CAJN,EAIS,CAJT,EAIY,CAJZ,EAIe,CAJf,EAIkB,CAJlB,EAIqB,CAJrB,EAIwB,CAJxB,EAI2B,CAJ3B,EAKlB,CALkB,EAKf,CALe,EAKZ,CALY,EAKT,CALS,EAKN,CALM,EAKH,CALG,EAKA,CALA,EAKG,CALH,EAKM,CALN,EAKS,CALT,EAKY,CALZ,EAKe,CALf,EAKkB,CALlB,EAKqB,CALrB,EAKwB,CALxB,EAK2B,CAL3B,EAMlB,CANkB,EAMf,CANe,EAMZ,CANY,EAMT,CANS,EAMN,CANM,EAMH,CANG,EAMA,CANA,EAMG,CANH,EAMM,CANN,EAMS,CANT,EAMY,CANZ,EAMe,CANf,EAMkB,CANlB,EAMqB,CANrB,EAMwB,CANxB,EAM2B,CAN3B,EAOlB,CAPkB,EAOf,CAPe,EAOZ,CAPY,EAOT,CAPS,EAON,CAPM,EAOH,CAPG,EAOA,CAPA,EAOG,CAPH,EAOM,CAPN,EAOS,CAPT,EAOY,CAPZ,EAOe,CAPf,EAOkB,CAPlB,EAOqB,CAPrB,EAOwB,CAPxB,EAO2B,CAP3B,EAQlB,CARkB,EAQf,CARe,EAQZ,CARY,EAQT,CARS,EAQN,CARM,EAQH,CARG,EAQA,CARA,EAQG,CARH,EAQM,CARN,EAQS,CART,EAQY,CARZ,EAQe,CARf,EAQkB,CARlB,EAQqB,CARrB,EAQwB,CARxB,EAQ2B,CAR3B,EASlB,CATkB,EASf,CATe,EASZ,CATY,EAST,CATS,EASN,CATM,EASH,CATG,EASA,CATA,EASG,CATH,EASM,CATN,EASS,CATT,EASY,CATZ,EASe,CATf,EASkB,CATlB,EASqB,CATrB,EASwB,CATxB,EAS2B,CAT3B,EAUlB,CAVkB,EAUf,CAVe,EAUZ,CAVY,EAUT,CAVS,EAUN,CAVM,EAUH,CAVG,EAUA,CAVA,EAUG,CAVH,EAUM,CAVN,EAUS,CAVT,EAUY,CAVZ,EAUe,CAVf,EAUkB,CAVlB,EAUqB,CAVrB,EAUwB,CAVxB,EAU2B,CAV3B,EAWlB,CAXkB,EAWf,CAXe,EAWZ,CAXY,EAWT,CAXS,EAWN,CAXM,EAWH,CAXG,EAWA,CAXA,EAWG,CAXH,EAWM,CAXN,EAWS,CAXT,EAWY,CAXZ,EAWe,CAXf,EAWkB,CAXlB,EAWqB,CAXrB,EAWwB,CAXxB,EAW2B,CAX3B,EAYlB,CAZkB,EAYf,CAZe,EAYZ,CAZY,EAYT,CAZS,EAYN,CAZM,EAYH,CAZG,EAYA,CAZA,EAYG,CAZH,EAYM,CAZN,EAYS,CAZT,EAYY,CAZZ,EAYe,CAZf,EAYkB,CAZlB,EAYqB,CAZrB,EAYwB,CAZxB,EAY2B,CAZ3B,EAalB,CAbkB,EAaf,CAbe,EAaZ,CAbY,EAaT,CAbS,EAaN,CAbM,EAaH,CAbG,EAaA,CAbA,EAaG,CAbH,EAaM,CAbN,EAaS,CAbT,EAaY,CAbZ,EAae,CAbf,EAakB,CAblB,EAaqB,CAbrB,EAawB,CAbxB,EAa2B,CAb3B,EAclB,CAdkB,EAcf,CAde,EAcZ,CAdY,EAcT,CAdS,EAcN,CAdM,EAcH,CAdG,EAcA,CAdA,EAcG,CAdH,EAcM,CAdN,EAcS,CAdT,EAcY,CAdZ,EAce,CAdf,EAckB,CAdlB,EAcqB,CAdrB,EAcwB,CAdxB,EAc2B,CAd3B,EAelB,CAfkB,EAef,CAfe,EAeZ,CAfY,EAeT,CAfS,EAeN,CAfM,EAeH,CAfG,EAeA,CAfA,EAeG,CAfH,EAeM,CAfN,EAeS,CAfT,EAeY,CAfZ,EAee,CAff,EAekB,CAflB,EAeqB,CAfrB,EAewB,CAfxB,EAe2B,CAf3B,EAgBlB,CAhBkB,EAgBf,CAhBe,EAgBZ,CAhBY,EAgBT,CAhBS,EAgBN,CAhBM,EAgBH,CAhBG,EAgBA,CAhBA,EAgBG,CAhBH,EAgBM,CAhBN,EAgBS,CAhBT,EAgBY,CAhBZ,EAgBe,CAhBf,EAgBkB,CAhBlB,EAgBqB,CAhBrB,EAgBwB,CAhBxB,EAgB2B,CAhB3B,CAgB6B;AAhB7B,CAAtB;;AAkBA,SAASvF,sBAAT,CAAgCwF,GAAhC,EAAqC;AACjCA,EAAAA,GAAG,IAAI,EAAP;AACA,MAAIA,GAAG,CAACrB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACoB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnC3I,IAAAA,KAAK,CAAC,oCAAD,EAAuC0I,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACrB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACoB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnC3I,IAAAA,KAAK,CAAC,oCAAD,EAAuC0I,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACrB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACoB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnC3I,IAAAA,KAAK,CAAC,oCAAD,EAAuC0I,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,MAAID,GAAG,CAACrB,MAAJ,GAAa,CAAjB,EACI,OAAO,KAAP;;AACJ,MAAI,CAACoB,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAD,CAAlB,EAAuC;AACnC3I,IAAAA,KAAK,CAAC,oCAAD,EAAuC0I,GAAG,CAACC,UAAJ,CAAe,CAAf,CAAvC,CAAL;AACA,WAAO,IAAP;AACH;;AACD,OAAK,IAAIzE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGwE,GAAG,CAACrB,MAAxB,EAAgC,EAAEnD,CAAlC,EAAqC;AACjC,QAAI,CAACuE,aAAa,CAACC,GAAG,CAACC,UAAJ,CAAezE,CAAf,CAAD,CAAlB,EAAuC;AACnClE,MAAAA,KAAK,CAAC,uCAAD,EAA0CkE,CAA1C,EAA6CwE,GAAG,CAACC,UAAJ,CAAezE,CAAf,CAA7C,CAAL;AACA,aAAO,IAAP;AACH;AACJ;;AACD,SAAO,KAAP;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Server = void 0;\nconst qs = require(\"querystring\");\nconst url_1 = require(\"url\");\nconst base64id = require(\"base64id\");\nconst transports_1 = require(\"./transports\");\nconst events_1 = require(\"events\");\nconst socket_1 = require(\"./socket\");\nconst debug_1 = require(\"debug\");\nconst cookie_1 = require(\"cookie\");\nconst ws_1 = require(\"ws\");\nconst debug = (0, debug_1.default)(\"engine\");\nclass Server extends events_1.EventEmitter {\n    /**\n     * Server constructor.\n     *\n     * @param {Object} opts - options\n     * @api public\n     */\n    constructor(opts = {}) {\n        super();\n        this.clients = {};\n        this.clientsCount = 0;\n        this.opts = Object.assign({\n            wsEngine: ws_1.Server,\n            pingTimeout: 20000,\n            pingInterval: 25000,\n            upgradeTimeout: 10000,\n            maxHttpBufferSize: 1e6,\n            transports: Object.keys(transports_1.default),\n            allowUpgrades: true,\n            httpCompression: {\n                threshold: 1024\n            },\n            cors: false,\n            allowEIO3: false\n        }, opts);\n        if (opts.cookie) {\n            this.opts.cookie = Object.assign({\n                name: \"io\",\n                path: \"/\",\n                // @ts-ignore\n                httpOnly: opts.cookie.path !== false,\n                sameSite: \"lax\"\n            }, opts.cookie);\n        }\n        if (this.opts.cors) {\n            this.corsMiddleware = require(\"cors\")(this.opts.cors);\n        }\n        if (opts.perMessageDeflate) {\n            this.opts.perMessageDeflate = Object.assign({\n                threshold: 1024\n            }, opts.perMessageDeflate);\n        }\n        this.init();\n    }\n    /**\n     * Initialize websocket server\n     *\n     * @api private\n     */\n    init() {\n        if (!~this.opts.transports.indexOf(\"websocket\"))\n            return;\n        if (this.ws)\n            this.ws.close();\n        this.ws = new this.opts.wsEngine({\n            noServer: true,\n            clientTracking: false,\n            perMessageDeflate: this.opts.perMessageDeflate,\n            maxPayload: this.opts.maxHttpBufferSize\n        });\n        if (typeof this.ws.on === \"function\") {\n            this.ws.on(\"headers\", (headersArray, req) => {\n                // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)\n                // we could also try to parse the array and then sync the values, but that will be error-prone\n                const additionalHeaders = {};\n                const isInitialRequest = !req._query.sid;\n                if (isInitialRequest) {\n                    this.emit(\"initial_headers\", additionalHeaders, req);\n                }\n                this.emit(\"headers\", additionalHeaders, req);\n                Object.keys(additionalHeaders).forEach(key => {\n                    headersArray.push(`${key}: ${additionalHeaders[key]}`);\n                });\n            });\n        }\n    }\n    /**\n     * Returns a list of available transports for upgrade given a certain transport.\n     *\n     * @return {Array}\n     * @api public\n     */\n    upgrades(transport) {\n        if (!this.opts.allowUpgrades)\n            return [];\n        return transports_1.default[transport].upgradesTo || [];\n    }\n    /**\n     * Verifies a request.\n     *\n     * @param {http.IncomingMessage}\n     * @return {Boolean} whether the request is valid\n     * @api private\n     */\n    verify(req, upgrade, fn) {\n        // transport check\n        const transport = req._query.transport;\n        if (!~this.opts.transports.indexOf(transport)) {\n            debug('unknown transport \"%s\"', transport);\n            return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });\n        }\n        // 'Origin' header check\n        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);\n        if (isOriginInvalid) {\n            const origin = req.headers.origin;\n            req.headers.origin = null;\n            debug(\"origin header invalid\");\n            return fn(Server.errors.BAD_REQUEST, {\n                name: \"INVALID_ORIGIN\",\n                origin\n            });\n        }\n        // sid check\n        const sid = req._query.sid;\n        if (sid) {\n            if (!this.clients.hasOwnProperty(sid)) {\n                debug('unknown sid \"%s\"', sid);\n                return fn(Server.errors.UNKNOWN_SID, {\n                    sid\n                });\n            }\n            const previousTransport = this.clients[sid].transport.name;\n            if (!upgrade && previousTransport !== transport) {\n                debug(\"bad request: unexpected transport without upgrade\");\n                return fn(Server.errors.BAD_REQUEST, {\n                    name: \"TRANSPORT_MISMATCH\",\n                    transport,\n                    previousTransport\n                });\n            }\n        }\n        else {\n            // handshake is GET only\n            if (\"GET\" !== req.method) {\n                return fn(Server.errors.BAD_HANDSHAKE_METHOD, {\n                    method: req.method\n                });\n            }\n            if (!this.opts.allowRequest)\n                return fn();\n            return this.opts.allowRequest(req, (message, success) => {\n                if (!success) {\n                    return fn(Server.errors.FORBIDDEN, {\n                        message\n                    });\n                }\n                fn();\n            });\n        }\n        fn();\n    }\n    /**\n     * Prepares a request by processing the query string.\n     *\n     * @api private\n     */\n    prepare(req) {\n        // try to leverage pre-existing `req._query` (e.g: from connect)\n        if (!req._query) {\n            req._query = ~req.url.indexOf(\"?\") ? qs.parse((0, url_1.parse)(req.url).query) : {};\n        }\n    }\n    /**\n     * Closes all clients.\n     *\n     * @api public\n     */\n    close() {\n        debug(\"closing all open clients\");\n        for (let i in this.clients) {\n            if (this.clients.hasOwnProperty(i)) {\n                this.clients[i].close(true);\n            }\n        }\n        if (this.ws) {\n            debug(\"closing webSocketServer\");\n            this.ws.close();\n            // don't delete this.ws because it can be used again if the http server starts listening again\n        }\n        return this;\n    }\n    /**\n     * Handles an Engine.IO HTTP request.\n     *\n     * @param {http.IncomingMessage} request\n     * @param {http.ServerResponse|http.OutgoingMessage} response\n     * @api public\n     */\n    handleRequest(req, res) {\n        debug('handling \"%s\" http request \"%s\"', req.method, req.url);\n        this.prepare(req);\n        req.res = res;\n        const callback = (errorCode, errorContext) => {\n            if (errorCode !== undefined) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortRequest(res, errorCode, errorContext);\n                return;\n            }\n            if (req._query.sid) {\n                debug(\"setting new request for existing client\");\n                this.clients[req._query.sid].transport.onRequest(req);\n            }\n            else {\n                const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);\n                this.handshake(req._query.transport, req, closeConnection);\n            }\n        };\n        if (this.corsMiddleware) {\n            this.corsMiddleware.call(null, req, res, () => {\n                this.verify(req, false, callback);\n            });\n        }\n        else {\n            this.verify(req, false, callback);\n        }\n    }\n    /**\n     * generate a socket id.\n     * Overwrite this method to generate your custom socket id\n     *\n     * @param {Object} request object\n     * @api public\n     */\n    generateId(req) {\n        return base64id.generateId();\n    }\n    /**\n     * Handshakes a new client.\n     *\n     * @param {String} transport name\n     * @param {Object} request object\n     * @param {Function} closeConnection\n     *\n     * @api private\n     */\n    async handshake(transportName, req, closeConnection) {\n        const protocol = req._query.EIO === \"4\" ? 4 : 3; // 3rd revision by default\n        if (protocol === 3 && !this.opts.allowEIO3) {\n            debug(\"unsupported protocol version\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,\n                message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],\n                context: {\n                    protocol\n                }\n            });\n            closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);\n            return;\n        }\n        let id;\n        try {\n            id = await this.generateId(req);\n        }\n        catch (e) {\n            debug(\"error while generating an id\");\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"ID_GENERATION_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        debug('handshaking client \"%s\"', id);\n        try {\n            var transport = new transports_1.default[transportName](req);\n            if (\"polling\" === transportName) {\n                transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;\n                transport.httpCompression = this.opts.httpCompression;\n            }\n            else if (\"websocket\" === transportName) {\n                transport.perMessageDeflate = this.opts.perMessageDeflate;\n            }\n            if (req._query && req._query.b64) {\n                transport.supportsBinary = false;\n            }\n            else {\n                transport.supportsBinary = true;\n            }\n        }\n        catch (e) {\n            debug('error handshaking to transport \"%s\"', transportName);\n            this.emit(\"connection_error\", {\n                req,\n                code: Server.errors.BAD_REQUEST,\n                message: Server.errorMessages[Server.errors.BAD_REQUEST],\n                context: {\n                    name: \"TRANSPORT_HANDSHAKE_ERROR\",\n                    error: e\n                }\n            });\n            closeConnection(Server.errors.BAD_REQUEST);\n            return;\n        }\n        const socket = new socket_1.Socket(id, this, transport, req, protocol);\n        transport.on(\"headers\", (headers, req) => {\n            const isInitialRequest = !req._query.sid;\n            if (isInitialRequest) {\n                if (this.opts.cookie) {\n                    headers[\"Set-Cookie\"] = [\n                        // @ts-ignore\n                        (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie)\n                    ];\n                }\n                this.emit(\"initial_headers\", headers, req);\n            }\n            this.emit(\"headers\", headers, req);\n        });\n        transport.onRequest(req);\n        this.clients[id] = socket;\n        this.clientsCount++;\n        socket.once(\"close\", () => {\n            delete this.clients[id];\n            this.clientsCount--;\n        });\n        this.emit(\"connection\", socket);\n    }\n    /**\n     * Handles an Engine.IO HTTP Upgrade.\n     *\n     * @api public\n     */\n    handleUpgrade(req, socket, upgradeHead) {\n        this.prepare(req);\n        this.verify(req, true, (errorCode, errorContext) => {\n            if (errorCode) {\n                this.emit(\"connection_error\", {\n                    req,\n                    code: errorCode,\n                    message: Server.errorMessages[errorCode],\n                    context: errorContext\n                });\n                abortUpgrade(socket, errorCode, errorContext);\n                return;\n            }\n            const head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api\n            upgradeHead = null;\n            // delegate to ws\n            this.ws.handleUpgrade(req, socket, head, websocket => {\n                this.onWebSocket(req, socket, websocket);\n            });\n        });\n    }\n    /**\n     * Called upon a ws.io connection.\n     *\n     * @param {ws.Socket} websocket\n     * @api private\n     */\n    onWebSocket(req, socket, websocket) {\n        websocket.on(\"error\", onUpgradeError);\n        if (transports_1.default[req._query.transport] !== undefined &&\n            !transports_1.default[req._query.transport].prototype.handlesUpgrades) {\n            debug(\"transport doesnt handle upgraded requests\");\n            websocket.close();\n            return;\n        }\n        // get client id\n        const id = req._query.sid;\n        // keep a reference to the ws.Socket\n        req.websocket = websocket;\n        if (id) {\n            const client = this.clients[id];\n            if (!client) {\n                debug(\"upgrade attempt for closed client\");\n                websocket.close();\n            }\n            else if (client.upgrading) {\n                debug(\"transport has already been trying to upgrade\");\n                websocket.close();\n            }\n            else if (client.upgraded) {\n                debug(\"transport had already been upgraded\");\n                websocket.close();\n            }\n            else {\n                debug(\"upgrading existing transport\");\n                // transport error handling takes over\n                websocket.removeListener(\"error\", onUpgradeError);\n                const transport = new transports_1.default[req._query.transport](req);\n                if (req._query && req._query.b64) {\n                    transport.supportsBinary = false;\n                }\n                else {\n                    transport.supportsBinary = true;\n                }\n                transport.perMessageDeflate = this.perMessageDeflate;\n                client.maybeUpgrade(transport);\n            }\n        }\n        else {\n            // transport error handling takes over\n            websocket.removeListener(\"error\", onUpgradeError);\n            const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);\n            this.handshake(req._query.transport, req, closeConnection);\n        }\n        function onUpgradeError() {\n            debug(\"websocket error before upgrade\");\n            // websocket.close() not needed\n        }\n    }\n    /**\n     * Captures upgrade requests for a http.Server.\n     *\n     * @param {http.Server} server\n     * @param {Object} options\n     * @api public\n     */\n    attach(server, options = {}) {\n        let path = (options.path || \"/engine.io\").replace(/\\/$/, \"\");\n        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;\n        // normalize path\n        path += \"/\";\n        function check(req) {\n            return path === req.url.substr(0, path.length);\n        }\n        // cache and clean up listeners\n        const listeners = server.listeners(\"request\").slice(0);\n        server.removeAllListeners(\"request\");\n        server.on(\"close\", this.close.bind(this));\n        server.on(\"listening\", this.init.bind(this));\n        // add request handler\n        server.on(\"request\", (req, res) => {\n            if (check(req)) {\n                debug('intercepting request for path \"%s\"', path);\n                this.handleRequest(req, res);\n            }\n            else {\n                let i = 0;\n                const l = listeners.length;\n                for (; i < l; i++) {\n                    listeners[i].call(server, req, res);\n                }\n            }\n        });\n        if (~this.opts.transports.indexOf(\"websocket\")) {\n            server.on(\"upgrade\", (req, socket, head) => {\n                if (check(req)) {\n                    this.handleUpgrade(req, socket, head);\n                }\n                else if (false !== options.destroyUpgrade) {\n                    // default node behavior is to disconnect when no handlers\n                    // but by adding a handler, we prevent that\n                    // and if no eio thing handles the upgrade\n                    // then the socket needs to die!\n                    setTimeout(function () {\n                        if (socket.writable && socket.bytesWritten <= 0) {\n                            return socket.end();\n                        }\n                    }, destroyUpgradeTimeout);\n                }\n            });\n        }\n    }\n}\nexports.Server = Server;\n/**\n * Protocol errors mappings.\n */\nServer.errors = {\n    UNKNOWN_TRANSPORT: 0,\n    UNKNOWN_SID: 1,\n    BAD_HANDSHAKE_METHOD: 2,\n    BAD_REQUEST: 3,\n    FORBIDDEN: 4,\n    UNSUPPORTED_PROTOCOL_VERSION: 5\n};\nServer.errorMessages = {\n    0: \"Transport unknown\",\n    1: \"Session ID unknown\",\n    2: \"Bad handshake method\",\n    3: \"Bad request\",\n    4: \"Forbidden\",\n    5: \"Unsupported protocol version\"\n};\n/**\n * Close the HTTP long-polling request\n *\n * @param res - the response object\n * @param errorCode - the error code\n * @param errorContext - additional error context\n *\n * @api private\n */\nfunction abortRequest(res, errorCode, errorContext) {\n    const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;\n    const message = errorContext && errorContext.message\n        ? errorContext.message\n        : Server.errorMessages[errorCode];\n    res.writeHead(statusCode, { \"Content-Type\": \"application/json\" });\n    res.end(JSON.stringify({\n        code: errorCode,\n        message\n    }));\n}\n/**\n * Close the WebSocket connection\n *\n * @param {net.Socket} socket\n * @param {string} errorCode - the error code\n * @param {object} errorContext - additional error context\n *\n * @api private\n */\nfunction abortUpgrade(socket, errorCode, errorContext = {}) {\n    socket.on(\"error\", () => {\n        debug(\"ignoring error from closed connection\");\n    });\n    if (socket.writable) {\n        const message = errorContext.message || Server.errorMessages[errorCode];\n        const length = Buffer.byteLength(message);\n        socket.write(\"HTTP/1.1 400 Bad Request\\r\\n\" +\n            \"Connection: close\\r\\n\" +\n            \"Content-type: text/html\\r\\n\" +\n            \"Content-Length: \" +\n            length +\n            \"\\r\\n\" +\n            \"\\r\\n\" +\n            message);\n    }\n    socket.destroy();\n}\n/* eslint-disable */\n/**\n * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354\n *\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n *\n * checkInvalidHeaderChar() is currently designed to be inlinable by v8,\n * so take care when making changes to the implementation so that the source\n * code size does not exceed v8's default max_inlined_source_size setting.\n **/\n// prettier-ignore\nconst validHdrChars = [\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255\n];\nfunction checkInvalidHeaderChar(val) {\n    val += \"\";\n    if (val.length < 1)\n        return false;\n    if (!validHdrChars[val.charCodeAt(0)]) {\n        debug('invalid header, index 0, char \"%s\"', val.charCodeAt(0));\n        return true;\n    }\n    if (val.length < 2)\n        return false;\n    if (!validHdrChars[val.charCodeAt(1)]) {\n        debug('invalid header, index 1, char \"%s\"', val.charCodeAt(1));\n        return true;\n    }\n    if (val.length < 3)\n        return false;\n    if (!validHdrChars[val.charCodeAt(2)]) {\n        debug('invalid header, index 2, char \"%s\"', val.charCodeAt(2));\n        return true;\n    }\n    if (val.length < 4)\n        return false;\n    if (!validHdrChars[val.charCodeAt(3)]) {\n        debug('invalid header, index 3, char \"%s\"', val.charCodeAt(3));\n        return true;\n    }\n    for (let i = 4; i < val.length; ++i) {\n        if (!validHdrChars[val.charCodeAt(i)]) {\n            debug('invalid header, index \"%i\", char \"%s\"', i, val.charCodeAt(i));\n            return true;\n        }\n    }\n    return false;\n}\n"]},"metadata":{},"sourceType":"script"}